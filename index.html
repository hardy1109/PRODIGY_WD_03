<!-- Save this as index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ultimate Tic-Tac-Toe</title>
  <style>
    * { box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body {
      margin: 0;
      background: linear-gradient(-45deg, #ffecd2, #fcb69f, #a1c4fd, #c2e9fb);
      background-size: 400% 400%;
      animation: gradient 15s ease infinite;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      color: #333;
    }
    @keyframes gradient {
      0% { background-position: 0% 50% }
      50% { background-position: 100% 50% }
      100% { background-position: 0% 50% }
    }
    h1 { margin-top: 20px; }
    .controls, .timer, .scores, .start-options {
      margin: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 10px 15px;
      font-size: 1em;
      border: none;
      background-color: #555;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover { background-color: #333; }
    .board {
      display: grid;
      grid-template-columns: repeat(3, 80px);
      grid-gap: 5px;
      margin: 20px;
    }
    .cell {
      width: 80px;
      height: 80px;
      background-color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2em;
      border-radius: 5px;
      cursor: pointer;
    }
    .dark-mode { background-color: #121212; color: white; }
    .dark-mode .cell { background-color: #333; color: #fff; }
    .hidden { display: none; }
    .ai-settings {
      display: flex;
      gap: 5px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .highlight { background-color: yellow !important; }
    #resultMessage {
      font-size: 1.5em;
      margin-bottom: 15px;
      padding: 10px 20px;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      display: none;
    }
    @media (max-width: 500px) {
      .board { grid-template-columns: repeat(3, 60px); }
      .cell { width: 60px; height: 60px; font-size: 1.5em; }
      button { font-size: 0.9em; padding: 8px 12px; }
    }
  </style>
</head>
<body>
  <h1>‚ú® Tic-Tac-Toe</h1>

  <div class="controls">
    <button onclick="playClickSound(); startGame('2P')">2 Players</button>
    <button onclick="playClickSound(); startGame('AI')">VS AI</button>
    <button onclick="playClickSound(); restartGame()">Restart</button>
    <button onclick="playClickSound(); undoMove()">Undo</button>
    <button onclick="playClickSound(); redoMove()">Redo</button>
    <button onclick="toggleDarkMode()">üåó Dark Mode</button>
  </div>

  <div class="ai-settings hidden" id="aiSettings">
    <button onclick="playClickSound(); setAILevel('easy')">Easy</button>
    <button onclick="playClickSound(); setAILevel('medium')">Medium</button>
    <button onclick="playClickSound(); setAILevel('hard')">Hard</button>
  </div>

  <div class="timer">
    ‚è±Ô∏è Player X Time: <span id="timerX">0s</span> |
    ‚è±Ô∏è Player O Time: <span id="timerO">0s</span>
  </div>

  <div class="scores">
    üîµ Player X Wins: <span id="scoreX">0</span> |
    üî¥ Player O Wins: <span id="scoreO">0</span>
  </div>

  <div id="resultMessage"></div>
  <div class="board" id="board"></div>

  <audio id="tickSound" src="tic-tac-27828.mp3" loop></audio>
  <audio id="playerXSound" src="toggle-button-on-166329.mp3"></audio>
  <audio id="playerOSound" src="toggle-button-off-166328.mp3"></audio>
  <audio id="winSound" src="success-1-6297.mp3"></audio>
  <audio id="clickSound" src="button-click-sound.mp3"></audio>

  <script>
    const boardEl = document.getElementById('board');
    const timerXEl = document.getElementById('timerX');
    const timerOEl = document.getElementById('timerO');
    const scoreXEl = document.getElementById('scoreX');
    const scoreOEl = document.getElementById('scoreO');
    const tickSound = document.getElementById('tickSound');
    const xSound = document.getElementById('playerXSound');
    const oSound = document.getElementById('playerOSound');
    const winSound = document.getElementById('winSound');
    const clickSound = document.getElementById('clickSound');
    const aiSettingsEl = document.getElementById('aiSettings');
    const resultMessageEl = document.getElementById('resultMessage');

    let board = Array(9).fill('');
    let currentPlayer = 'X';
    let vsAI = false;
    let aiLevel = 'easy';
    let gameActive = false;
    let history = [], future = [];
    let timerX = 0, timerO = 0;
    let timerInterval;
    let scores = { X: 0, O: 0 };
    let timerStarted = false;

    function playClickSound() {
      clickSound.currentTime = 0;
      clickSound.play();
    }

    function startGame(mode) {
      vsAI = (mode === 'AI');
      aiSettingsEl.classList.toggle('hidden', !vsAI);
      scores = { X: 0, O: 0 };
      updateScores();
      resetBoard();
      gameActive = true;
      currentPlayer = 'X';
    }

    function resetBoard() {
      board = Array(9).fill('');
      history = [[...board]];
      future = [];
      gameActive = true;
      boardEl.innerHTML = '';
      clearInterval(timerInterval);
      tickSound.pause();
      timerX = 0;
      timerO = 0;
      timerXEl.textContent = '0s';
      timerOEl.textContent = '0s';
      timerStarted = false;
      resultMessageEl.style.display = 'none';
      resultMessageEl.textContent = '';
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.onclick = handleCellClick;
        boardEl.appendChild(cell);
      }
    }

    function handleCellClick(e) {
      const index = e.target.dataset.index;
      if (!gameActive || board[index]) return;
      if (!timerStarted) {
        startTimer();
        timerStarted = true;
      }
      makeMove(index);
      if (checkWin()) return;
      if (vsAI && currentPlayer === 'O') {
        setTimeout(() => {
          aiMove();
          checkWin();
        }, 300);
      }
    }

    function makeMove(index) {
      board[index] = currentPlayer;
      updateBoard();
      history.push([...board]);
      future = [];
      (currentPlayer === 'X' ? xSound : oSound).play();
      currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
    }

    function updateBoard() {
      Array.from(boardEl.children).forEach((cell, i) => {
        cell.textContent = board[i];
        cell.classList.remove('highlight');
      });
    }

    function checkWin() {
      const combos = [
        [0,1,2], [3,4,5], [6,7,8],
        [0,3,6], [1,4,7], [2,5,8],
        [0,4,8], [2,4,6]
      ];
      for (let combo of combos) {
        const [a,b,c] = combo;
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
          highlightWin(combo);
          winSound.play();
          gameActive = false;
          clearInterval(timerInterval);
          tickSound.pause();
          scores[board[a]]++;
          updateScores();
          showResultMessage(`üéâ Player ${board[a]} Wins!`);
          return true;
        }
      }
      if (!board.includes('')) {
        gameActive = false;
        clearInterval(timerInterval);
        tickSound.pause();
        showResultMessage("ü§ù It's a Tie!");
      }
      return false;
    }

    function showResultMessage(message) {
      resultMessageEl.textContent = message;
      resultMessageEl.style.display = 'block';
    }

    function highlightWin(combo) {
      combo.forEach(i => boardEl.children[i].classList.add('highlight'));
    }

    function updateScores() {
      scoreXEl.textContent = scores.X;
      scoreOEl.textContent = scores.O;
    }

    function restartGame() {
      resetBoard();
    }

    function undoMove() {
      if (history.length > 1) {
        future.push(history.pop());
        board = [...history[history.length - 1]];
        currentPlayer = history.length % 2 === 1 ? 'X' : 'O';
        updateBoard();
        gameActive = true;
        resultMessageEl.style.display = 'none';
      }
    }

    function redoMove() {
      if (future.length) {
        const next = future.pop();
        history.push([...next]);
        board = [...next];
        currentPlayer = history.length % 2 === 1 ? 'X' : 'O';
        updateBoard();
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
    }

    function setAILevel(level) {
      aiLevel = level;
      restartGame();
    }

    function aiMove() {
      if (!gameActive) return;
      let index;
      const empty = board.map((v, i) => v === '' ? i : null).filter(v => v !== null);
      if (aiLevel === 'easy') {
        index = empty[Math.floor(Math.random() * empty.length)];
      } else if (aiLevel === 'medium') {
        index = findBestMove('O') ?? empty[Math.floor(Math.random() * empty.length)];
      } else {
        index = minimax(board, 'O').index;
      }
      if (index !== undefined && board[index] === '') {
        makeMove(index);
      }
    }

    function findBestMove(player) {
      for (let i = 0; i < 9; i++) {
        if (board[i] === '') {
          const tempBoard = [...board];
          tempBoard[i] = player;
          if (isWinning(tempBoard, player)) return i;
        }
      }
      const opponent = player === 'O' ? 'X' : 'O';
      for (let i = 0; i < 9; i++) {
        if (board[i] === '') {
          const tempBoard = [...board];
          tempBoard[i] = opponent;
          if (isWinning(tempBoard, opponent)) return i;
        }
      }
      return null;
    }

    function isWinning(simBoard, player) {
      const combos = [
        [0,1,2], [3,4,5], [6,7,8],
        [0,3,6], [1,4,7], [2,5,8],
        [0,4,8], [2,4,6]
      ];
      return combos.some(([a,b,c]) =>
        simBoard[a] === player && simBoard[b] === player && simBoard[c] === player
      );
    }

    function minimax(newBoard, player) {
      const availSpots = newBoard.map((v, i) => v === '' ? i : null).filter(v => v !== null);
      const opponent = player === 'O' ? 'X' : 'O';

      if (isWinning(newBoard, 'X')) return { score: -10 };
      if (isWinning(newBoard, 'O')) return { score: 10 };
      if (availSpots.length === 0) return { score: 0 };

      const moves = [];
      for (let i = 0; i < availSpots.length; i++) {
        const move = {};
        move.index = availSpots[i];
        newBoard[availSpots[i]] = player;

        const result = minimax(newBoard, opponent);
        move.score = result.score;

        newBoard[availSpots[i]] = '';
        moves.push(move);
      }

      let bestMove;
      if (player === 'O') {
        let bestScore = -Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score > bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      } else {
        let bestScore = Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score < bestScore) {
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      }

      return moves[bestMove];
    }

    function startTimer() {
      clearInterval(timerInterval);
      tickSound.play();
      timerInterval = setInterval(() => {
        if (currentPlayer === 'X') {
          timerX++;
          timerXEl.textContent = `${timerX}s`;
        } else {
          timerO++;
          timerOEl.textContent = `${timerO}s`;
        }
      }, 1000);
    }

    startGame('2P');
  </script>
</body>
</html>
